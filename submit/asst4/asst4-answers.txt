1)  What are the ELF magic numbers?

    - ELFMAG0: 0x7f
    - ELFMAG1: 'E'
    - ELFMAG2: 'L'
    - ELFMAG3: 'F'
    - e_indent[EI_MAG0 ... 3] holdds these magic numbers

2)  What is the difference between UIO_USERISPACE and UIO_USERSPACE? 
    When should one use UIO_SYSSPACE instead?

    - UIO_USERISPACE contains executable user process code.
    - UIO_USERSPACE contains user process data.
    - UIO_SYSSPACE should be used when transferring data within kernel space.

3)  Why can the struct uio that is used to read in a segment be allocated on 
    the stack in load_segment() (i.e., where does the memory read actually go)?

    The data from memory read goes into the virtual address space pointed to by
    the pointer *as which was passed in as an argument to the load_segment()
    function.
    TODO: WHY STACK?!

4)  In runprogram(), why is it important to call vfs_close() before going 
    to usermode?

    - We are done with the file and no longer need its file descriptor.
    - So we don't leave the file open and create memory leaks.

5)  What function forces the processor to switch into usermode? 
    Is this function machine dependent?

    - enter_new_process() in trap.c, line 423, which calls mips_usermode().
    - It is hardware dependent. Passing argc/argv may use additional stack 
    space on some other platforms (but not on mips).

6)  In what file are copyin and copyout defined? memmove? 
    Why can't copyin and copyout be implemented as simply as memmove?

    - copyin and copyout are defined in copyinout.c
    - memmove is defined in memmove.c
    - copyin and copyout use copycheck to make sure the block of user memory 
    provided is not illegal. Makes sure that the user isn't passing in 
    illegal addresses.

7)  What (briefly) is the purpose of userptr_t?

    - userptr_t is a pointer that is used to point to a user-space address

8)  What is the numerical value of the exception code for a MIPS system call?
    
    - #define EX_SYS 8

9)  How many bytes is an instruction in MIPS? (Answer this by reading syscall() 
    carefully, not by looking somewhere else.)

    - 4 bytes
    - The program counter is advanced by 4 at the end of syscall

10) Why do you "probably want to change" the implementation of kill_curthread()?

    - At the moment, the kernel just panics when user-level code hits a 
    fatal fault.
    - Ideally, we would want it to be handled in some way instead.

11) What would be required to implement a system call that took more 
    than 4 arguments?

    - Use copyin() to fetch the extra arguments from the user-level stack, 
    starting at sp+16.

12) What is the purpose of the SYSCALL macro?

    - It allows the system to load syscall values into the v0 register where 
    the kernel can find it
    - It then jumps to the shared syscall code

13) What is the MIPS instruction that actually triggers a system call? 
    (Answer this by reading the source in this directory, not looking 
    somewhere else.)
    
    - syscall (line 84 of syscall-mips.S)

14) After reading syscalls-mips.S and syscall.c, you should be prepared to 
    answer the following question: OS/161 supports 64-bit values; lseek() 
    takes and returns a 64-bit offset value. Thus, lseek() takes a 32-bit file 
    handle (arg0), a 64-bit offset (arg1), a 32-bit whence (arg2), and needs 
    to return a 64-bit offset value. In void syscall(struct trapframe *tf) 
    where will you find each of the three arguments (in which registers) and 
    how will you return the 64-bit offset?

    - arg0 is found inside tf->a0
    - arg1 is split between tf->a2 and tf->a3 (32 bits per register)
    - arg2 is found on the stack
    - 64-bit offset will be split and returned in registers v0 and v1 (32 bits
      per register)

15) As you were reading the code in runprogram.c and loadelf.c, you probably 
    noticed how the kernel manipulates the files. Which kernel function is 
    called to open a file? Which macro is called to read the file? 
    What about to write a file? Which data structure is used in the kernel 
    to represent an open file? 

    - vfs_open to open a file
    - VOP_READ macro to read a file
    - VOP_WRITE macro to write a file
    - vnode data structure to represent an open file

16) What is the purpose of VOP_INCREF and VOP_DECREF?
    
    - VOP_INCREF is used as a macro to increment the reference count
    - VOP_DECREF is used as a macro to decrement the reference count
